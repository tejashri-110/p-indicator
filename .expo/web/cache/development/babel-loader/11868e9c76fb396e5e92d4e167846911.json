{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _common = require(\"@react-native-firebase/app/lib/common\");\n\nvar _NativeFirebaseError = _interopRequireDefault(require(\"@react-native-firebase/app/lib/internal/NativeFirebaseError\"));\n\nvar _FirestoreDocumentSnapshot = _interopRequireDefault(require(\"./FirestoreDocumentSnapshot\"));\n\nvar _FirestoreFieldPath = _interopRequireWildcard(require(\"./FirestoreFieldPath\"));\n\nvar _FirestoreQuerySnapshot = _interopRequireDefault(require(\"./FirestoreQuerySnapshot\"));\n\nvar _utils = require(\"./utils\");\n\nvar _id = 0;\n\nvar FirestoreQuery = function () {\n  function FirestoreQuery(firestore, collectionPath, modifiers) {\n    (0, _classCallCheck2.default)(this, FirestoreQuery);\n    this._firestore = firestore;\n    this._collectionPath = collectionPath;\n    this._modifiers = modifiers;\n  }\n\n  (0, _createClass2.default)(FirestoreQuery, [{\n    key: \"_handleQueryCursor\",\n    value: function _handleQueryCursor(cursor, docOrField, fields) {\n      var modifiers = this._modifiers._copy();\n\n      if ((0, _common.isUndefined)(docOrField)) {\n        throw new Error(\"firebase.firestore().collection().\" + cursor + \"(*) Expected a DocumentSnapshot or list of field values but got undefined.\");\n      }\n\n      if (docOrField instanceof _FirestoreDocumentSnapshot.default) {\n        if (fields.length > 0) {\n          throw new Error(\"firebase.firestore().collection().\" + cursor + \"(*) Too many arguments provided. Expected DocumentSnapshot or list of field values.\");\n        }\n\n        var documentSnapshot = docOrField;\n\n        if (!documentSnapshot.exists) {\n          throw new Error(\"firebase.firestore().collection().\" + cursor + \"(*) Can't use a DocumentSnapshot that doesn't exist.\");\n        }\n\n        var currentOrders = modifiers.orders;\n        var values = [];\n\n        for (var i = 0; i < currentOrders.length; i++) {\n          var order = currentOrders[i];\n\n          if (order.fieldPath === '__name__') {\n            continue;\n          }\n\n          var value = documentSnapshot.get(order.fieldPath);\n\n          if (value === undefined) {\n            throw new Error(\"firebase.firestore().collection().\" + cursor + \"(*) You are trying to start or end a query using a document for which the field '\" + order.fieldPath + \"' (used as the orderBy) does not exist.\");\n          }\n\n          values.push(value);\n        }\n\n        if (modifiers._orders.length) {\n          var lastOrder = modifiers._orders[modifiers._orders.length - 1];\n\n          if (lastOrder.fieldPath !== '__name__') {\n            modifiers._orders.push({\n              fieldPath: '__name__',\n              direction: lastOrder.direction\n            });\n          }\n        } else {\n          modifiers._orders.push({\n            fieldPath: '__name__',\n            direction: 'ASCENDING'\n          });\n        }\n\n        if (this._modifiers.isCollectionGroupQuery()) {\n          values.push(documentSnapshot.ref.path);\n        } else {\n          values.push(documentSnapshot.id);\n        }\n\n        return modifiers.setFieldsCursor(cursor, values);\n      }\n\n      var allFields = [docOrField].concat(fields);\n\n      if (allFields.length > modifiers.orders.length) {\n        throw new Error(\"firebase.firestore().collection().\" + cursor + \"(*) Too many arguments provided. The number of arguments must be less than or equal to the number of orderBy() clauses.\");\n      }\n\n      return modifiers.setFieldsCursor(cursor, allFields);\n    }\n  }, {\n    key: \"endAt\",\n    value: function endAt(docOrField) {\n      for (var _len = arguments.length, fields = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        fields[_key - 1] = arguments[_key];\n      }\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('endAt', docOrField, fields));\n    }\n  }, {\n    key: \"endBefore\",\n    value: function endBefore(docOrField) {\n      for (var _len2 = arguments.length, fields = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        fields[_key2 - 1] = arguments[_key2];\n      }\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('endBefore', docOrField, fields));\n    }\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      var _this = this;\n\n      if (!(0, _common.isUndefined)(options) && !(0, _common.isObject)(options)) {\n        throw new Error(\"firebase.firestore().collection().get(*) 'options' must be an object is provided.\");\n      }\n\n      if (options && options.source && options.source !== 'default' && options.source !== 'server' && options.source !== 'cache') {\n        throw new Error(\"firebase.firestore().collection().get(*) 'options' GetOptions.source must be one of 'default', 'server' or 'cache'.\");\n      }\n\n      this._modifiers.validatelimitToLast();\n\n      return this._firestore.native.collectionGet(this._collectionPath.relativeName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, options).then(function (data) {\n        return new _FirestoreQuerySnapshot.default(_this._firestore, _this, data);\n      });\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      if (!(other instanceof FirestoreQuery)) {\n        throw new Error(\"firebase.firestore().collection().isEqual(*) 'other' expected a Query instance.\");\n      }\n\n      if (this.firestore.app.name !== other.firestore.app.name || this._modifiers.type !== other._modifiers.type || this._modifiers.filters.length !== other._modifiers.filters.length || this._modifiers.orders.length !== other._modifiers.orders.length || this._collectionPath.relativeName !== other._collectionPath.relativeName || Object.keys(this._modifiers.options).length !== Object.keys(other._modifiers.options).length) {\n        return false;\n      }\n\n      if (JSON.stringify(this._modifiers.filters) !== JSON.stringify(other._modifiers.filters) || JSON.stringify(this._modifiers.orders) !== JSON.stringify(other._modifiers.orders) || JSON.stringify(this._modifiers.options) !== JSON.stringify(other._modifiers.options)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      if (this._modifiers.isValidLimit(_limit)) {\n        throw new Error(\"firebase.firestore().collection().limit(*) 'limit' must be a positive integer value.\");\n      }\n\n      var modifiers = this._modifiers._copy().limit(_limit);\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n    }\n  }, {\n    key: \"limitToLast\",\n    value: function limitToLast(_limitToLast) {\n      if (this._modifiers.isValidLimitToLast(_limitToLast)) {\n        throw new Error(\"firebase.firestore().collection().limitToLast(*) 'limitToLast' must be a positive integer value.\");\n      }\n\n      var modifiers = this._modifiers._copy().limitToLast(_limitToLast);\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n    }\n  }, {\n    key: \"onSnapshot\",\n    value: function onSnapshot() {\n      var _this2 = this;\n\n      var snapshotListenOptions;\n      var callback;\n      var onNext;\n      var onError;\n\n      this._modifiers.validatelimitToLast();\n\n      try {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        var options = (0, _utils.parseSnapshotArgs)(args);\n        snapshotListenOptions = options.snapshotListenOptions;\n        callback = options.callback;\n        onNext = options.onNext;\n        onError = options.onError;\n      } catch (e) {\n        throw new Error(\"firebase.firestore().collection().onSnapshot(*) \" + e.message);\n      }\n\n      function handleSuccess(querySnapshot) {\n        callback(querySnapshot, null);\n        onNext(querySnapshot);\n      }\n\n      function handleError(error) {\n        callback(null, error);\n        onError(error);\n      }\n\n      var listenerId = _id++;\n\n      var onSnapshotSubscription = this._firestore.emitter.addListener(this._firestore.eventNameForApp(\"firestore_collection_sync_event:\" + listenerId), function (event) {\n        if (event.body.error) {\n          handleError(_NativeFirebaseError.default.fromEvent(event.body.error, 'firestore'));\n        } else {\n          var querySnapshot = new _FirestoreQuerySnapshot.default(_this2._firestore, _this2, event.body.snapshot);\n          handleSuccess(querySnapshot);\n        }\n      });\n\n      var unsubscribe = function unsubscribe() {\n        onSnapshotSubscription.remove();\n\n        _this2._firestore.native.collectionOffSnapshot(listenerId);\n      };\n\n      this._firestore.native.collectionOnSnapshot(this._collectionPath.relativeName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, listenerId, snapshotListenOptions);\n\n      return unsubscribe;\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      if (!(0, _common.isString)(fieldPath) && !(fieldPath instanceof _FirestoreFieldPath.default)) {\n        throw new Error(\"firebase.firestore().collection().orderBy(*) 'fieldPath' must be a string or instance of FieldPath.\");\n      }\n\n      var path;\n\n      if ((0, _common.isString)(fieldPath)) {\n        try {\n          path = (0, _FirestoreFieldPath.fromDotSeparatedString)(fieldPath);\n        } catch (e) {\n          throw new Error(\"firebase.firestore().collection().orderBy(*) 'fieldPath' \" + e.message + \".\");\n        }\n      } else {\n        path = fieldPath;\n      }\n\n      if (!(0, _common.isUndefined)(directionStr) && !this._modifiers.isValidDirection(directionStr)) {\n        throw new Error(\"firebase.firestore().collection().orderBy(_, *) 'directionStr' must be one of 'asc' or 'desc'.\");\n      }\n\n      if (this._modifiers.hasStart()) {\n        throw new Error('firebase.firestore().collection().orderBy() Invalid query. You must not call startAt() or startAfter() before calling orderBy().');\n      }\n\n      if (this._modifiers.hasEnd()) {\n        throw new Error('firebase.firestore().collection().orderBy() Invalid query. You must not call endAt() or endBefore() before calling orderBy().');\n      }\n\n      var modifiers = this._modifiers._copy().orderBy(path, directionStr);\n\n      try {\n        modifiers.validateOrderBy();\n      } catch (e) {\n        throw new Error(\"firebase.firestore().collection().orderBy() \" + e.message);\n      }\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n    }\n  }, {\n    key: \"startAfter\",\n    value: function startAfter(docOrField) {\n      for (var _len4 = arguments.length, fields = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        fields[_key4 - 1] = arguments[_key4];\n      }\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('startAfter', docOrField, fields));\n    }\n  }, {\n    key: \"startAt\",\n    value: function startAt(docOrField) {\n      for (var _len5 = arguments.length, fields = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        fields[_key5 - 1] = arguments[_key5];\n      }\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('startAt', docOrField, fields));\n    }\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      if (!(0, _common.isString)(fieldPath) && !(fieldPath instanceof _FirestoreFieldPath.default)) {\n        throw new Error(\"firebase.firestore().collection().where(*) 'fieldPath' must be a string or instance of FieldPath.\");\n      }\n\n      var path;\n\n      if ((0, _common.isString)(fieldPath)) {\n        try {\n          path = (0, _FirestoreFieldPath.fromDotSeparatedString)(fieldPath);\n        } catch (e) {\n          throw new Error(\"firebase.firestore().collection().where(*) 'fieldPath' \" + e.message + \".\");\n        }\n      } else {\n        path = fieldPath;\n      }\n\n      if (!this._modifiers.isValidOperator(opStr)) {\n        throw new Error(\"firebase.firestore().collection().where(_, *) 'opStr' is invalid. Expected one of '==', '>', '>=', '<', '<=', '!=', 'array-contains', 'not-in', 'array-contains-any' or 'in'.\");\n      }\n\n      if ((0, _common.isUndefined)(value)) {\n        throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' argument expected.\");\n      }\n\n      if ((0, _common.isNull)(value) && !this._modifiers.isEqualOperator(opStr)) {\n        throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' is invalid. You can only perform equals comparisons on null\");\n      }\n\n      if (this._modifiers.isInOperator(opStr)) {\n        if (!(0, _common.isArray)(value) || !value.length) {\n          throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' is invalid. A non-empty array is required for '\" + opStr + \"' filters.\");\n        }\n\n        if (value.length > 10) {\n          throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' is invalid. '\" + opStr + \"' filters support a maximum of 10 elements in the value array.\");\n        }\n      }\n\n      var modifiers = this._modifiers._copy().where(path, opStr, value);\n\n      try {\n        modifiers.validateWhere();\n      } catch (e) {\n        throw new Error(\"firebase.firestore().collection().where() \" + e.message);\n      }\n\n      return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n    }\n  }, {\n    key: \"firestore\",\n    get: function get() {\n      return this._firestore;\n    }\n  }]);\n  return FirestoreQuery;\n}();\n\nexports.default = FirestoreQuery;","map":{"version":3,"sources":["C:/Users/mitba/React Native/p-indicator-1/node_modules/@react-native-firebase/firestore/lib/FirestoreQuery.js"],"names":["_id","FirestoreQuery","firestore","collectionPath","modifiers","_firestore","_collectionPath","_modifiers","cursor","docOrField","fields","_copy","Error","FirestoreDocumentSnapshot","length","documentSnapshot","exists","currentOrders","orders","values","i","order","fieldPath","value","get","undefined","push","_orders","lastOrder","direction","isCollectionGroupQuery","ref","path","id","setFieldsCursor","allFields","concat","_handleQueryCursor","options","source","validatelimitToLast","native","collectionGet","relativeName","type","filters","then","data","FirestoreQuerySnapshot","other","app","name","Object","keys","JSON","stringify","limit","isValidLimit","limitToLast","isValidLimitToLast","snapshotListenOptions","callback","onNext","onError","args","e","message","handleSuccess","querySnapshot","handleError","error","listenerId","onSnapshotSubscription","emitter","addListener","eventNameForApp","event","body","NativeError","fromEvent","snapshot","unsubscribe","remove","collectionOffSnapshot","collectionOnSnapshot","directionStr","FirestoreFieldPath","isValidDirection","hasStart","hasEnd","orderBy","validateOrderBy","opStr","isValidOperator","isEqualOperator","isInOperator","where","validateWhere"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  isArray,\n  isNull,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreDocumentSnapshot from './FirestoreDocumentSnapshot';\nimport FirestoreFieldPath, { fromDotSeparatedString } from './FirestoreFieldPath';\nimport FirestoreQuerySnapshot from './FirestoreQuerySnapshot';\nimport { parseSnapshotArgs } from './utils';\n\nlet _id = 0;\n\nexport default class FirestoreQuery {\n  constructor(firestore, collectionPath, modifiers) {\n    this._firestore = firestore;\n    this._collectionPath = collectionPath;\n    this._modifiers = modifiers;\n  }\n\n  get firestore() {\n    return this._firestore;\n  }\n\n  _handleQueryCursor(cursor, docOrField, fields) {\n    const modifiers = this._modifiers._copy();\n\n    if (isUndefined(docOrField)) {\n      throw new Error(\n        `firebase.firestore().collection().${cursor}(*) Expected a DocumentSnapshot or list of field values but got undefined.`,\n      );\n    }\n\n    // Handles cases where the first arg is a DocumentSnapshot\n    if (docOrField instanceof FirestoreDocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new Error(\n          `firebase.firestore().collection().${cursor}(*) Too many arguments provided. Expected DocumentSnapshot or list of field values.`,\n        );\n      }\n\n      const documentSnapshot = docOrField;\n\n      if (!documentSnapshot.exists) {\n        throw new Error(\n          `firebase.firestore().collection().${cursor}(*) Can't use a DocumentSnapshot that doesn't exist.`,\n        );\n      }\n\n      const currentOrders = modifiers.orders;\n\n      const values = [];\n\n      for (let i = 0; i < currentOrders.length; i++) {\n        const order = currentOrders[i];\n        //skip if fieldPath is '__name__'\n        if (order.fieldPath === '__name__') {\n          continue;\n        }\n\n        const value = documentSnapshot.get(order.fieldPath);\n\n        if (value === undefined) {\n          throw new Error(\n            `firebase.firestore().collection().${cursor}(*) You are trying to start or end a query using a document for which the field '${order.fieldPath}' (used as the orderBy) does not exist.`,\n          );\n        }\n\n        values.push(value);\n      }\n\n      // Based on https://github.com/invertase/react-native-firebase/issues/2854#issuecomment-552986650\n      if (modifiers._orders.length) {\n        const lastOrder = modifiers._orders[modifiers._orders.length - 1];\n        //push '__name__' field only if not present already\n        if (lastOrder.fieldPath !== '__name__') {\n          modifiers._orders.push({\n            fieldPath: '__name__',\n            direction: lastOrder.direction,\n          });\n        }\n      } else {\n        modifiers._orders.push({\n          fieldPath: '__name__',\n          direction: 'ASCENDING',\n        });\n      }\n\n      if (this._modifiers.isCollectionGroupQuery()) {\n        values.push(documentSnapshot.ref.path);\n      } else {\n        values.push(documentSnapshot.id);\n      }\n\n      return modifiers.setFieldsCursor(cursor, values);\n    }\n\n    /**\n     * Assumes list of field values to query by. Orders must be of equal length.\n     */\n\n    const allFields = [docOrField].concat(fields);\n\n    if (allFields.length > modifiers.orders.length) {\n      throw new Error(\n        `firebase.firestore().collection().${cursor}(*) Too many arguments provided. The number of arguments must be less than or equal to the number of orderBy() clauses.`,\n      );\n    }\n\n    return modifiers.setFieldsCursor(cursor, allFields);\n  }\n\n  endAt(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('endAt', docOrField, fields),\n    );\n  }\n\n  endBefore(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('endBefore', docOrField, fields),\n    );\n  }\n\n  get(options) {\n    if (!isUndefined(options) && !isObject(options)) {\n      throw new Error(\n        \"firebase.firestore().collection().get(*) 'options' must be an object is provided.\",\n      );\n    }\n\n    if (\n      options &&\n      options.source &&\n      options.source !== 'default' &&\n      options.source !== 'server' &&\n      options.source !== 'cache'\n    ) {\n      throw new Error(\n        \"firebase.firestore().collection().get(*) 'options' GetOptions.source must be one of 'default', 'server' or 'cache'.\",\n      );\n    }\n\n    this._modifiers.validatelimitToLast();\n\n    return this._firestore.native\n      .collectionGet(\n        this._collectionPath.relativeName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        options,\n      )\n      .then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n  }\n\n  isEqual(other) {\n    if (!(other instanceof FirestoreQuery)) {\n      throw new Error(\n        \"firebase.firestore().collection().isEqual(*) 'other' expected a Query instance.\",\n      );\n    }\n\n    // Carry out lightweight checks first\n    if (\n      this.firestore.app.name !== other.firestore.app.name ||\n      this._modifiers.type !== other._modifiers.type ||\n      this._modifiers.filters.length !== other._modifiers.filters.length ||\n      this._modifiers.orders.length !== other._modifiers.orders.length ||\n      this._collectionPath.relativeName !== other._collectionPath.relativeName ||\n      Object.keys(this._modifiers.options).length !== Object.keys(other._modifiers.options).length\n    ) {\n      return false;\n    }\n\n    // Carry out potentially expensive checks\n    // noinspection RedundantIfStatementJS\n    if (\n      JSON.stringify(this._modifiers.filters) !== JSON.stringify(other._modifiers.filters) ||\n      JSON.stringify(this._modifiers.orders) !== JSON.stringify(other._modifiers.orders) ||\n      JSON.stringify(this._modifiers.options) !== JSON.stringify(other._modifiers.options)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  limit(limit) {\n    if (this._modifiers.isValidLimit(limit)) {\n      throw new Error(\n        \"firebase.firestore().collection().limit(*) 'limit' must be a positive integer value.\",\n      );\n    }\n\n    const modifiers = this._modifiers._copy().limit(limit);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n  }\n\n  limitToLast(limitToLast) {\n    if (this._modifiers.isValidLimitToLast(limitToLast)) {\n      throw new Error(\n        \"firebase.firestore().collection().limitToLast(*) 'limitToLast' must be a positive integer value.\",\n      );\n    }\n\n    const modifiers = this._modifiers._copy().limitToLast(limitToLast);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n  }\n\n  onSnapshot(...args) {\n    let snapshotListenOptions;\n    let callback;\n    let onNext;\n    let onError;\n\n    this._modifiers.validatelimitToLast();\n\n    try {\n      const options = parseSnapshotArgs(args);\n      snapshotListenOptions = options.snapshotListenOptions;\n      callback = options.callback;\n      onNext = options.onNext;\n      onError = options.onError;\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().onSnapshot(*) ${e.message}`);\n    }\n\n    function handleSuccess(querySnapshot) {\n      callback(querySnapshot, null);\n      onNext(querySnapshot);\n    }\n\n    function handleError(error) {\n      callback(null, error);\n      onError(error);\n    }\n\n    const listenerId = _id++;\n\n    const onSnapshotSubscription = this._firestore.emitter.addListener(\n      this._firestore.eventNameForApp(`firestore_collection_sync_event:${listenerId}`),\n      event => {\n        if (event.body.error) {\n          handleError(NativeError.fromEvent(event.body.error, 'firestore'));\n        } else {\n          const querySnapshot = new FirestoreQuerySnapshot(\n            this._firestore,\n            this,\n            event.body.snapshot,\n          );\n          handleSuccess(querySnapshot);\n        }\n      },\n    );\n\n    const unsubscribe = () => {\n      onSnapshotSubscription.remove();\n      this._firestore.native.collectionOffSnapshot(listenerId);\n    };\n\n    this._firestore.native.collectionOnSnapshot(\n      this._collectionPath.relativeName,\n      this._modifiers.type,\n      this._modifiers.filters,\n      this._modifiers.orders,\n      this._modifiers.options,\n      listenerId,\n      snapshotListenOptions,\n    );\n\n    return unsubscribe;\n  }\n\n  orderBy(fieldPath, directionStr) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\n        \"firebase.firestore().collection().orderBy(*) 'fieldPath' must be a string or instance of FieldPath.\",\n      );\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().orderBy(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!isUndefined(directionStr) && !this._modifiers.isValidDirection(directionStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().orderBy(_, *) 'directionStr' must be one of 'asc' or 'desc'.\",\n      );\n    }\n\n    if (this._modifiers.hasStart()) {\n      throw new Error(\n        'firebase.firestore().collection().orderBy() Invalid query. You must not call startAt() or startAfter() before calling orderBy().',\n      );\n    }\n\n    if (this._modifiers.hasEnd()) {\n      throw new Error(\n        'firebase.firestore().collection().orderBy() Invalid query. You must not call endAt() or endBefore() before calling orderBy().',\n      );\n    }\n\n    const modifiers = this._modifiers._copy().orderBy(path, directionStr);\n\n    try {\n      modifiers.validateOrderBy();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().orderBy() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n  }\n\n  startAfter(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('startAfter', docOrField, fields),\n    );\n  }\n\n  startAt(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('startAt', docOrField, fields),\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(*) 'fieldPath' must be a string or instance of FieldPath.\",\n      );\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().where(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!this._modifiers.isValidOperator(opStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(_, *) 'opStr' is invalid. Expected one of '==', '>', '>=', '<', '<=', '!=', 'array-contains', 'not-in', 'array-contains-any' or 'in'.\",\n      );\n    }\n\n    if (isUndefined(value)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(_, _, *) 'value' argument expected.\",\n      );\n    }\n\n    if (isNull(value) && !this._modifiers.isEqualOperator(opStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(_, _, *) 'value' is invalid. You can only perform equals comparisons on null\",\n      );\n    }\n\n    if (this._modifiers.isInOperator(opStr)) {\n      if (!isArray(value) || !value.length) {\n        throw new Error(\n          `firebase.firestore().collection().where(_, _, *) 'value' is invalid. A non-empty array is required for '${opStr}' filters.`,\n        );\n      }\n\n      if (value.length > 10) {\n        throw new Error(\n          `firebase.firestore().collection().where(_, _, *) 'value' is invalid. '${opStr}' filters support a maximum of 10 elements in the value array.`,\n        );\n      }\n    }\n\n    const modifiers = this._modifiers._copy().where(path, opStr, value);\n\n    try {\n      modifiers.validateWhere();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().where() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}